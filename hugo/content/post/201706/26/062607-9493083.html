+++
date = "2017-06-26T07:00:00"
title = "這些被遺忘的編程語言，還在訴說他們的故事"
titleimage = "https://pic3.zhimg.com/v2-0c917bbdece813141549a1ee49fc4c2a.jpg"
ga = 062607
+++

<div class="main-wrap content-wrap">
<div class="headline">

<div class="img-place-holder"></div>



</div>

<div class="content-inner">




<div class="question">
<h2 class="question-title">爲什麼我們需要了解編程的歷史？</h2>

<div class="answer">



<div class="content">
<p><strong>因爲這些被遺忘的語言，還在訴說他們的故事啊。</strong></p>
<p><strong>去自然化</strong></p>
<p>1978 年，爲了記錄下編程語言的發展，展開了會議。</p>
<p>這某種意義上，算是 PL 的&lsquo;華山論劍&rsquo;-</p>
<p>天下各路 PL 中極小數強者，聚集（語言不會走路，是這些語言的設計師&amp;實現者聚集）。</p>
<p>13 個入選的語言中，5 個有圖靈獎得主參與！（APL, Algol, Fortran, Lisp, Simula）</p>
<p>這等豪華陣容，只怕再也湊不出。</p>
<p>當然，沒有什麼比武。不過，之後又舉辦了兩次 HOPL，總計三次，真是個美妙的巧合啊。</p>
<p>在這個大會上，Opening 是 Grace Hopper，Cobol 的主刀。</p>
<p>我讀到這的時候，也很不解。</p>
<p>Cobol 何德何能，爲何能佔着 Opening，這位置上面的 5 個&lsquo;圖靈獎語言&rsquo;那個不更有資格？</p>
<p>她說：&ldquo;我被你們震驚到了。你們都是權威，然而我這輩子花了 20 年去跟權威作鬥爭！PL 早期中我們最常聽到的話是&lsquo;編程計算機的唯一方法是 8 進制。&rsquo;（省略）在那時，權威跟我們說，用計算機編程是不可能的，計算機唯一能做的只有算術。&rdquo;</p>
<p>一個編程語言，條件判斷靠 if else，自指用遞歸，組成更大的數據類型用 struct。。。</p>
<p>這幾個構造如此天經地義，導致看上去沒有任何其他 alternative：還能怎麼弄。</p>
<p>然而，連&lsquo;編程語言&rsquo;在當時很多人眼中都是不可能，這些構造又怎麼可能&lsquo;自然&rsquo;呢？</p>
<p>if else，是 1960 左右，John Mccarthy 發明，並且加入 Algol 60。</p>
<p>在此以前，Fortran 只有 if 後面跟着一個 int 表達式，然後跟着三個整數 - 跳轉的行號！</p>
<p>（沒錯，goto 在當時是跳轉到行號的）</p>
<p>當然，Fortran 也一樣被&lsquo;權威&rsquo;看不起，認爲&lsquo;一切高級編程語言都很慢，不夠用&rsquo;。</p>
<p>聽上去像不像 C 語言程序員嘲笑其他高級語言慢？</p>
<p>這就是學歷史的另一個好處：知道什麼論點會被歷史的車輪碾壓。</p>
<p>PL 的遞歸，是同時由 John Mccarthy 發明的。值得一提的是，這特性差點沒進 Algol 60。</p>
<p>至於 struct，一開始只有 Cobol 纔有，到了近 8 年後，到了 Algol 68，才傳播到各個語言。</p>
<p>函數式程序員別得意，John 自己也搞不懂啥是 Lambda Calculus，到了 1964 Peter Landin 才指出 Lambda Calculus 可以用來編程。</p>
<p>而事實上，if else, recursion, struct, lambda，全部都有人改過，並且投入使用。</p>
<p>把 if else 改成 if ... else if ... else if ... （沒有最終 else），然後不規定同時滿足多個條件時，進入那個分支（non determinism），就有 Dijkstra 的 Guard Command Language。這個語言可以由於是不確定的，可以用來組合多線程的 blocking channel（見 Concepts of Programming Languages）。有趣的是，Dijkstra 發明的時候，沒想這麼多，只是因爲單純的&lsquo;if else 不對稱，好醜&rsquo;而去改。</p>
<p>遞歸則可以完全去掉，改由 recursion scheme（list 的 foldr 或者相近的，但是更復雜的，構造 / 使用數據結構的高階函數）。用 recursion scheme 的人，有時候會說&lsquo;無限制的遞歸就是新的 goto&rsquo;。這是因爲對於用了遞歸的程序，要證明這程序的屬性，只能用歸納法，而如果用 recursion scheme，就能用事先（通過歸納法）證明的引理去輔助證明。打個比方，如果你用 list 上的 map，而不是手動遞歸，你寫程序的時候就能引用定理 map f . map g = map (f . g)。（注：map 不是 recursion scheme）</p>
<p>至於 struct，在 Algol 68 中，就提供了 Algebraic Data Type。除了&lsquo;類型 T 能通過給人類型 X 跟類型 Y 的值來構造&rsquo;以外，還有&lsquo;類型 T 能通過給入類型 X<strong>或類</strong>型 Y 的值來構造&rsquo;。這跟 union 有點像，但是會記下是&lsquo;或的那邊&rsquo;，換句話說，是 disjoint union。這特性是用來描述 AST（Abstract Syntax Tree）的首選，所以基本上所有鍾愛元編程的靜態類型語言（如 ML，Haskell）都有。</p>
<p>而 lambda calculus 中的 arrow type，在 linear logic（一種限制所有資源都必須使用剛好一次的邏輯系統）中，則可以拆分成兩個更細的 construct：a -&gt; b = !a -o b。其中，!x 代表可以任意複製的 x，x -o y 代表給入一個 x，消耗之，輸出一個 y。!a -o b 則表明，給入可以任意複製的 a，消耗之，輸出一個 b。由於 a 可以任意複製，所以消耗了不要緊，換句話說這就是給入 a，輸出 b。（見 A Taste Of Linear Logic）同時，在 OO 界，Luca 由於 Lambda Calculus 的限制，難以用之模擬 class，object，subtyping，於是自己發明了另一套 calculus - Object Calculus（見 A Theory of Object）。</p>
<p>還有一個怪胎，APL- 這語言裏面拋棄了這些概念，一切都通過對數組的變換來完成。（其實還是有的，不過不提倡使用）</p>
<p>不學歷史，很容易認爲這些東西生來如此，沒什麼好改的 - 儘管計算機的發明還不到 100 年！</p>
<p>同時，看着這些先驅開天闢地，創造一切，有莫名的史詩感，說不出的好受。</p>
<p><strong>提取精華</strong></p>
<p>等你學了點歷史，對編程語言的可塑性有更深刻理解，並且開始假想基本構造的更多形式的時候，你就到達破而後立的&lsquo;破&rsquo;了。當然，破而後立，你還需要會寫 Parser/Compiler/Interpreter/VM，會弄類型系統，宏，等等。。。</p>
<p><strong>然而，這還不夠。</strong></p>
<p>一個語言，首先是一種編程方法，一套認爲人類如何編程最高效的理論，然後纔是圍繞着這個理論而生的 feature。世界上絕大部分（不是完全沒人用）的語言，如 Algol, Cobol, Fortran, APL, C, C++, Python, Perl, Scheme, Haskell, Smalltalk, CPL。。。都有這東西。</p>
<p>在 C++ 中，這叫 Design Philosophy, 在 Python 中，稱作是 pythonic，Smalltalk 中，是 Design Principle。。。我們統稱之爲 Principle。沒有 Principle，造出的語言，只能是舊有語言的無機混合，看上去很好，然而沒有新意。</p>
<p>Principle 是一個語言的內核。有了 Principle，可以用之更改過往的語言 construct，得出一個全新的語言。在 The Essence of Algol 中，John Reynold 就是從一個他認爲是 Algol 中很重要的部分，慢慢推出各種 construct，得出一個小而全的 Algol。</p>
<p>要注意，Principle 並不是爲了推出 Feature。相反，是 Feature 爲 Principle 服務。換句話說，如果一個語言中，有跟 Principle 不匹配的 Feature，要做減法，砍掉 Feature。</p>
<p>比如說，Structured Programming 認爲，由於測試不可能保證正確性，我們需要用 Hoare Logic 推出程序的正確性。但是，與其正推，我們可以一步步的從終止條件倒推，到最後，從證明中取出程序（又或者說，證明就是程序）。這叫做 Stepwise refinement，而 Structured Programming 捨棄 goto，不是因爲&lsquo;Structured Programming = Programming without goto&rsquo;，而是 Stepwise Refinement 恰巧不支持 Goto 而已。盲目的去掉 Goto，是治標不治本。</p>
<p>Functional Programming 則認爲，大的程序最好由小的，相互獨立的程序（兩個程序的用途都可以跟另一個分開）組合得出。如果程序 A 會影響程序 B，就不是相互獨立的，所以 FP 不提倡 Effect。在 FP 中，獨立組合性是治本，移除&amp;控制 Effect 是治標。</p>
<p>除了 Paradigm 的 Principle，每個語言自己也有各自的 Principle-Smalltalk 的是 Design Principles Behind Smalltalk，APL 的是 Notation as a Tool of Thought，Algol 的是 The Essence of Algol。學習 PL 史，是發現 Principle，並觀察 Principle 如何慢慢構造一個語言。</p>
<p><strong>正本清源</strong></p>
<p>除了發現 Principle，並觀察 Principle 的發展，影響，可以反着，研究 Principle 如何誕生。</p>
<p>這樣做，可以明白一個 Principle 的本質，又或者可以自己照貓畫虎，搞出自己的 Principle。</p>
<p>往往，這樣做會走出 PL，甚至 CS 的邊界。</p>
<p>Logo 對 smalltalk 有很大的影響（如 Alan Kay 對 Personal Computing 的理解就被 Logo 影響了，見 Early History of Smalltalk），而 Logo 的 3 Principle（Principle of Power，即學即用，Principle of Continuity，學的東西跟以往的東西有緊密連接，Principle of Culture，社區中其他人日常生活會接觸到學的東西），則來自 Jean Piaget 的認知發展理論。</p>
<p>同時，這些 Principle 的來源，說不定自身就很有啓發性，找到了，就是攢到了。</p>
<p>比如說，說遠一些，Robert Harper 發現了，就算是有 bug 的程序，也可以用 formal verification 的方式看待之。只不過，這時候證明就無法完成。然後，通過審視證明爲何無法完成，就知道 bug 在那，而無需要寫測試瞎猜。這叫 Proof Directed Debugging。</p>
<p>而這方法，來自於數學 / 哲學的著作，Proofs and Refutations。這本書講了數學證明的發展史，並且論述，數學證明並不是通過 Formal Proof 得出的，而是通過 trial and error。在此以前，我還以爲數學的發展是通過 Formal Proof&amp;Informal Hole 的，現在才明白除了寫證明，還有下定義，找猜想，generalize，debug 證明等等，也託這的福，找到了 Abductive reasoning。而這，僅僅因爲我看 Proof Directed Debugging 的時候查查這的歷史。</p>
<p><strong>爽！</strong></p>
<p>一方面，查歷史就像探寶一樣，往往會在意想不到的地方跳出驚人的事件：比如說，易語言的近似物在早近 30 年前，就已經出現了 - 由於 Algol 不限字符集，在 1972 就有一個叫 Chinese Algol 的方言。當然，還有更重要的，比如說設計 CPL，C 的前前前身的人，據說對 ISWIM 有不小的影響。</p>
<p>另一方面，<strong>丘處機爲什麼要路過牛家村？</strong></p>
<p>歷史學得越多，就會越來越發現當下的巧合，然後去幻想平行世界的展開。其中，最可惜的是，1948 年就有一個跟得上 60 年代的語言 - Plankalk&uuml;l。這是最早的，有 if/struct/loop 等的語言，足足超前了 Algol/Lisp/Cobol/Fortran 10 年！如果這語言更早被更多人知道，又或者 Algol 60 沒有引入遞歸，又或者 John Mccarthy, Alan Kay, Dijkstra, Seymour Papert, John Backus 等人改行。。。不知道那樣，我們現在會在用什麼語言呢。</p>
</div>
</div>




</div>


</div>
</div>