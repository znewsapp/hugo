+++
date = "2016-10-05T13:00:00"
title = "幾百 MB 的文件，解壓後達到幾個 GB，這是怎麼做到的？"
titleimage = "http://pic2.zhimg.com/230b73d5e5f0ce50f2bc76ded604898d.jpg"
ga = 100513
+++

<div class="main-wrap content-wrap">
<div class="headline">

<div class="img-place-holder"></div>



</div>

<div class="content-inner">




<div class="question">
<h2 class="question-title">高壓縮文件是如何實現的？</h2>

<div class="answer">



<div class="content">
<p>簡要概述原理：</p>
<p>每個文件都由各種不同代碼組成，比如 01 代碼。這類文件只有數字 0 與 1 組合。</p>
<p>壓縮原理就是&mdash;&mdash;<strong>通過尋找其中的規律，簡化數字的排列</strong>。</p>
<p>比如</p>
<p>00000110001111111111</p>
<p>可以簡化成</p>
<p>5 個 0,2 個 1,3 個 0,10 個 1 的排列</p>
<p>100000000000</p>
<p>可以簡化成數學的</p>
<p>10^10</p>
<p>至於@yskin 說 沒見過 2G 壓縮到十幾兆的。</p>
<p>實際上在極限壓縮方式下其實 28.1G 壓到 25.8M 都可以。</p>
<img class="content-image" src="http://pic1.zhimg.com/70/893534a767ddb047cc04dd66e2a43900_b.jpg" alt="">
<p>附下載：<a href="http://pan.baidu.com/share/link?shareid=551202611&amp;uk=1578952168">2^31-1 [AviSynth 16x16 60.000fps AVC-Lossless-yuv420p8]</a></p>
<p>打開看後基本都能理解這個壓縮的大概原理了。</p>
<p>下面是幾種常見文件壓縮算法原理介紹：</p>
<p>字典算法</p>
<p>字典算法是最爲簡單的壓縮算法之一。它是把文本中出現頻率比較多的單詞或詞彙組合做成一個對應的字典列表，並用特殊代碼來表示這個單詞或詞彙。例如：</p>
<p>有字典列表：</p>
<p>00=Chinese</p>
<p>01=People</p>
<p>02=China</p>
<p>源文本：I am a Chinese people,I am from China 壓縮後的編碼爲：I am a 00 01,I am from 02。壓縮編碼後的長度顯著縮小，這樣的編碼在 SLG 遊戲等專有名詞比較多的遊戲中比較容易出現，比如《SD 高達》。</p>
<p>&nbsp;</p>
<p>固定位長算法（Fixed Bit Length Packing）</p>
<p>這種算法是把文本用需要的最少的位來進行壓縮編碼。</p>
<p>比 如八個十六進制數：1，2，3，4，5，6，7，8。轉換爲二進制爲：00000001，00000010，00000011，00000100， 00000101，00000110，00000111，00001000。每個數只用到了低 4 位，而高 4 位沒有用到（全爲 0），因此對低 4 位進行壓縮編 碼後得到：0001，0010，0011，0100，0101，0110，0111，1000。然後補充爲字節得到：00010010， 00110100，01010110，01111000。所以原來的八個十六進制數縮短了一半，得到 4 個十六進制數：12，34，56，78。</p>
<p>這也是比較常見的壓縮算法之一。</p>
<p>&nbsp;</p>
<p>RLE（Run Length Encoding）</p>
<p>是一個針對無損壓縮的非常簡單的算法。它用重複字節和重複的次數來簡單描述來代替重複的字節。儘管簡單並且對於通常的壓縮非常低效，但它有的時候卻非常有用（例如，JPEG 就使用它）。</p>
<img class="content-image" src="http://pic3.zhimg.com/70/9e38c50349731f981ef777865bc0c796_b.jpg" alt="">
<p>原理圖 2.1 顯示了一個如何使用 RLE 算法來對一個數據流編碼的例子，其中出現六次的符號&lsquo;93&rsquo;已經用 3 個字節來代替：一個標記字節（&lsquo;0&rsquo;在本例中）重複的次數（&lsquo;6&rsquo;）和符號本身（&lsquo;93&rsquo;）。RLE 解碼器遇到符號&lsquo;0&rsquo;的時候，它表明後面的兩個字節決定了需要輸出哪個符號以及輸出多少次。</p>
<p>這種壓縮編碼是一種變長的編碼，RLE 根據文本不同的具體情況會有不同的壓縮編碼變體與之相適應，以產生更大的壓縮比率。</p>
<p>　　變體 1：重複次數 + 字符</p>
<p>文本字符串：A A A B B B C C C C D D D D，編碼後得到：3 A 3 B 4 C 4 D。</p>
<p>　　變體 2：特殊字符 + 重複次數 + 字符</p>
<p>文本字符串：A A A A A B C C C C B C C C，編碼後得到：B B 5 A B B 4 C B B 3 C。編碼串的最開始說明特殊字符 B，以後 B 後面跟着的數字就表示出重複的次數。</p>
<p>　　變體 3：把文本每個字節分組成塊，每個字符最多重複 127 次。每個塊以一個特殊字節開頭。那個特殊字節的第 7 位如果被置位，那麼剩下的 7 位數值就是後面的字符的重複次數。如果第 7 位沒有被置位，那麼剩下 7 位就是後面沒有被壓縮的字符的數量。例如：文本字符串：A A A A A B C D E F F F。編碼後得到：85 A 4 B C D E 83 F（85H= 10000101B、4H= 00000100B、83H= 10000011B）</p>
<p>實現 RLE 可以使用很多不同的方法。基本壓縮庫中詳細實現的方式是非常有效的一個。一個特殊的標記字節用來指示重複節的開始，而不是對於重複非重複節都 coding run。</p>
<p>因此非重複節可以有任意長度而不被控制字節打斷，除非指定的標記字節出現在非重複節（頂多以兩個字節來編碼）的稀有情況下。爲了最優化效率，標記字節應該是輸入流中最少出現的符號（或許就不存在）。</p>
<p>重複 runs 能夠在 32768 字節的時候運轉。少於 129 字節的要求 3 個字節編碼（標記 + 次數 + 符號），而大雨 128 字節要求四個字節（標記 + 次數的高 4 位|0x80+ 次數的低 4 位）。這是通常所有采用的壓縮的做法，並且也是相比較三個字節固定編碼（允許使用 3 個字節來編碼 256 個字節）而言非常少見的有損壓縮率的方法。</p>
<p>在這種模式下，最壞的壓縮結果是：</p>
<p>輸出大小=257/256* 輸入大小 +1</p>
<p>其他還有很多很多變體算法，這些算法在 Winzip Winrar 這些軟件中也是經常用到的。</p>
<p>&nbsp;</p>
<p>霍夫曼編碼（Huffman Encoding）</p>
<p>哈夫曼編碼是無損壓縮當中最好的方法。它使用預先二進制描述來替換每個符號，長度由特殊符號出現的頻率決定。常見的符號需要很少的位來表示，而不常見的符號需要很多爲來表示。</p>
<p>哈夫曼算法在改變任何符號二進制編碼引起少量密集表現方面是最佳的。然而，它並不處理符號的順序和重複或序號的序列。</p>
<p>原理我不打算探究哈夫曼編碼的所有實際的細節，但基本的原理是爲每個符號找到新的二進制表示，從而通常符號使用很少的位，不常見的符號使用較多的位。</p>
<p>簡短的說，這個問題的解決方案是爲了查找每個符號的通用程度，我們建立一個未壓縮數據的柱狀圖；通過遞歸拆分這個柱狀圖爲兩部分來創建一個二叉樹，每個遞歸的一半應該和另一半具有同樣的權（權是&sum;NK =1 符號數 k, N 是分之中符號的數量，符號數 k 是符號 k 出現的次數）</p>
<p>這棵樹有兩個目的：</p>
<p>1． 編碼器使用這棵樹來找到每個符號最優的表示方法</p>
<p>2． 解碼器使用這棵樹唯一的標識在壓縮流中每個編碼的開始和結束，其通過在讀壓縮數據位的時候自頂向底的遍歷樹，選擇基於數據流中的每個獨立位的分支，一旦一個到達葉子節點，解碼器知道一個完整的編碼已經讀出來了。</p>
<img class="content-image" src="http://pic4.zhimg.com/70/0c4287731b4b0174ae67c3c64816b07b_b.jpg" alt="">
<p>我們來看一個例子會讓我們更清楚。圖 2.2 顯示了一個 10 個字節的未壓縮的數據。</p>
<p>根據符號頻率，哈夫曼編碼器生成哈夫曼樹（圖 2.4）和相應的編碼表示（圖 2.3）。</p>
<img class="content-image" src="http://pic2.zhimg.com/70/8177f64bd55aebd5e01548c5a2697599_b.jpg" alt="">
<img class="content-image" src="http://pic4.zhimg.com/70/433e9e82ec457e6e78267cb26003d31b_b.jpg" alt="">
<p>你可以看到，常見的符號接近根，因此只要少數位來表示。於是最終的壓縮數據流如圖 2.5 所示。</p>
<img class="content-image" src="http://pic1.zhimg.com/70/0ac26ddbbd9fe23c74d57b22f3e826fc_b.jpg" alt="">
<p>壓縮後的數據流是 24 位（三個字節），原來是 80 位（10 個字節）。當然，我應該存儲哈夫曼樹，這樣解碼器就能夠解碼出對應的壓縮流了，這就使得該例子中的真正數據流比輸入的流數據量大。這是相對較短的數據上的副作用。對於大數據量來說，上面的哈夫曼樹就不佔太多比例了。解碼的時候，從上到下遍歷樹，爲壓縮的流選擇從左 / 右分支，每次碰到一個葉子節點的時候，就可以將對應的字節寫到解壓輸出流中，然後再從根開始遍歷。 實現哈夫曼編碼器可以在基本壓縮庫中找到，其是非常直接的實現。</p>
<p>這個實現的基本缺陷是：</p>
<p>1． 慢位流實現</p>
<p>2． 相當慢的解碼（比編碼慢）</p>
<p>3． 最大的樹深度是 32（編碼器在任何超過 32 位大小的時候退出）。如果我不是搞錯的話，這是不可能的，除非輸出的數據大於 232 字節。</p>
<p>另一方面，這個實現有幾個優點：</p>
<p>1． 哈夫曼樹以一個緊密的形式每個符號要求 12 位（對於 8 位的符號）的方式存儲，這意味着最大的頭爲 384。</p>
<p>2． 編碼相當容易理解</p>
<p>哈夫曼編碼在數據有噪音的情況（不是有規律的，例如 RLE）下非常好，這中情況下大多數基於字典方式的編碼器都有問題。</p>
<p>3. Rice 對於由大 word（例如：16 或 32 位）組成的數據和教低的數據值，Rice 編碼能夠獲得較好的壓縮比。音頻和高動態變化的圖像都是這種類型的數據，它們被某種預言預處理過（例如 delta 相鄰的採樣）。</p>
<p>儘管哈夫曼編碼處理這種數據是最優的，卻由於幾個原因而不適合處理這種數據（例如：32 位大小要求 16GB 的柱狀圖緩衝區來進行哈夫曼樹編碼）。因此一個比較動態的方式更適合由大 word 組成的數據。</p>
<p>原理 Rice 編碼背後的基本思想是儘可能的用較少的位來存儲多個字（正像使用哈夫曼編碼一樣）。實際上，有人可能想到 Rice 是靜態的哈夫曼編碼（例如，編碼不是由實際數據內容的統計信息決定，而是由小的值比高的值常見的假定決定）。</p>
<p>編碼非常簡單：將值 X 用 X 個&lsquo;1&rsquo;位之後跟一個 0 位來表示。</p>
<p>實現在基本壓縮庫針對 Rice 做了許多優化：</p>
<p>1． 每個字最沒有意義的位被存儲爲 k 和最有意義的 N-k 位用 Rice 編碼。K 作爲先前流中少許採樣的位平均數。這是通常最好使用 Rice 編碼的方法，隱藏噪音且對於動態變化的範圍並不導致非常長的 Rice 編碼。</p>
<p>2． 如果 rice 編碼比固定的開端長，T，一個可選的編碼：輸出 T 個&lsquo;1&rsquo;位，緊跟（log2(X-T)）個&lsquo;1&rsquo;和一個&lsquo;0&rsquo;位，接着是 X-T（最沒有意義的(log2(X-T))-1 位）。這對於大值來說都是比較高效的代碼並且阻止可笑的長 Rice 編碼（最壞的情況，對於一個 32 位 word 單個 Rice 編碼可能變成 232 位或 512MB）。</p>
<p>如果開端是 4，下面是結果編碼表：</p>
<p><strong>X</strong></p>
<p><strong>bin</strong></p>
<p><strong>Rice</strong></p>
<p><strong>Thresholded</strong></p>
<p><strong>Rice</strong></p>
<p>0</p>
<p>00000</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>00001</p>
<p>10</p>
<p>10</p>
<p>2</p>
<p>00010</p>
<p>110</p>
<p>110</p>
<p>3</p>
<p>00011</p>
<p>1110</p>
<p>1110</p>
<p>4</p>
<p>00100</p>
<p>11110</p>
<p>11110</p>
<p>5</p>
<p>00101</p>
<p>111110</p>
<p>111110</p>
<p>6</p>
<p>00110</p>
<p>1111110</p>
<p>11111100</p>
<p>+1</p>
<p>7</p>
<p>00111</p>
<p>11111110</p>
<p>11111101</p>
<p>8</p>
<p>01000</p>
<p>111111110</p>
<p>1111111000</p>
<p>+1</p>
<p>9</p>
<p>01001</p>
<p>1111111110</p>
<p>1111111001</p>
<p>10</p>
<p>01010</p>
<p>11111111110</p>
<p>1111111010</p>
<p>-1</p>
<p>11</p>
<p>01011</p>
<p>111111111110</p>
<p>1111111011</p>
<p>-2</p>
<p>12</p>
<p>01100</p>
<p>1111111111110</p>
<p>111111110000</p>
<p>13</p>
<p>01101</p>
<p>11111111111110</p>
<p>111111110001</p>
<p>-1</p>
<p>14</p>
<p>01110</p>
<p>111111111111110</p>
<p>111111110010</p>
<p>-2</p>
<p>15</p>
<p>01111</p>
<p>1111111111111110</p>
<p>111111110011</p>
<p>-3</p>
<p>16</p>
<p>10000</p>
<p>11111111111111110</p>
<p>111111110100</p>
<p>-4</p>
<p>17</p>
<p>10001</p>
<p>111111111111111110</p>
<p>111111110101</p>
<p>-5</p>
<p>18</p>
<p>10010</p>
<p>1111111111111111110</p>
<p>111111110110</p>
<p>-6</p>
<p>19</p>
<p>10011</p>
<p>11111111111111111110</p>
<p>111111110111</p>
<p>-7</p>
<p>20</p>
<p>10100</p>
<p>111111111111111111110</p>
<p>11111111100000</p>
<p>-5</p>
<p>就像你看到的一樣，在這個實現中使用 threshold 方法僅僅兩個編碼導致一個最壞的情況；剩下的編碼產生比標準 Rice 編碼還要短的編碼。</p>
<p>最壞的情況，輸出。</p>
<p>&nbsp;</p>
<p>Lempel-Ziv (LZ77)</p>
<p>Lempel-Ziv 壓縮模式有許多不同的變量。基本壓縮庫有清晰的 LZ77 算法的實現（Lempel-Ziv，1977），執行的很好，源代碼也非常容易理解。</p>
<p>LZ 編碼器能用來通用目標的壓縮，特別對於文本執行的很好。</p>
<p>它也在 RLE 和哈夫曼編碼器（RLE，LZ，哈夫曼）中使用來大多數情況下獲得更多的壓縮。這個壓縮算法是有版權的。</p>
<p>原理在 LZ 壓縮算法的背後是使用 RLE 算法用先前出現的相同字節序列的引用來替代。</p>
<p>簡單的講，LZ 算法被認爲是字符串匹配的算法。例如：在一段文本中某字符串經常出現，並且可以通過前面文本中出現的字符串指針來表示。當然這個想法的前提是指針應該比字符串本身要短。</p>
<p>例如，在上一段短語&ldquo;字符串&rdquo;經常出現，可以將除第一個字符串之外的所有用第一個字符串引用來表示從而節省一些空間。</p>
<p>一個字符串引用通過下面的方式來表示：</p>
<p>1． 唯一的標記</p>
<p>2． 偏移數量</p>
<p>3. 字符串長度</p>
<p>由編碼的模式決定引用是一個固定的或變動的長度。後面的情況經常是首選，因爲它允許編碼器用引用的大小來交換字符串的大小（例如，如果字符串相當長，增加引用的長度可能是值得的）。</p>
<p>實現使用 LZ77 的一個問題是由於算法需要字符串匹配，對於每個輸入流的單個字節，每個流中此字節前面的哪個字節都必須被作爲字符串的開始從而儘可能的進行字符串匹配，這意味着算法非常慢。</p>
<p>另一個問題是爲了最優化壓縮而調整字符串引用的表示形式並不容易。例如，必須決定是否所有的引用和非壓縮字節應該在壓縮流中的字節邊界發生。</p>
<p>基本壓縮庫使用一個清晰的實現來保證所有的符號和引用是字節對齊的，因此犧牲了壓縮比率，並且字符串匹配程序並不是最優化的（沒有緩存、歷史緩衝區或提高速度的小技巧），這意味着程序非常慢。</p>
<p>另一方面，解壓縮程序非常簡單。</p>
<p>一個提高 LZ77 速度的試驗已經進行了，這個試驗中使用數組索引來加速字符串匹配的過程。然而，它還是比通常的壓縮程序慢。</p>
<p>當然靜態數據和動態數據的壓縮策略是完全不同的。</p>
<p>一個壓縮文件是不是還可以用其他算法再繼續壓縮？</p>
<p>可以，但沒要。壓縮文件有極限值存在。高壓一遍已經很接近這個值了，再壓縮的話基本也就只有一丁點壓縮率提升，甚至會增加體積。</p>
<img class="content-image" src="http://pic2.zhimg.com/70/d39444f5ed75d4c444f483cda88a68b9_b.jpg" alt="">
<p>隨便做的渣繪圖。不要在意細節&rarr; &rarr;</p>
<p>&nbsp;</p>
<p>下面是題外話。</p>
<p>那麼一般要如何簡單實現高壓縮？</p>
<p>系統文件諸如 GAL 遊戲跟一些純代碼的文檔基本能直接用 7Z 進行<strong>無損壓縮</strong>就可以了。當然，高壓縮率也意味着更費時間的壓縮跟解壓。壓縮率小的沒必要用 7z，直接打包反而更適合。</p>
<p>影音圖像文件多數壓縮率只能通過再編碼有損壓縮。比如 BMP 圖像轉 jpg 吧圖片的一些一般人用不到的雜信息去除，APE 轉 MP3 之類。基本除了音源文件外其他要對比不太明顯。(照片 BMP 通過 7Z 壓縮後解壓其實是有點變化的，這個不細說，一說就沒完沒了了。)</p>
<p>至於有的人說我上面附帶的極限壓縮例子太坑爹，於是再附帶一個我做的動畫壓制 1080p BDMV 通過 10bit x264 再編碼壓縮成每話 90M 大小視頻。源 BDBOX 總大小 119.16GB。</p>
<p>畫面的話我【個人主觀看法】覺得在電腦觀看跟源盤沒什麼區別。（PS3 跟一些高端硬件芯片的解碼器播放那是另一回事了）</p>
<p>畫面控追求的 BDMV 無損畫質也是<strong>相對無損</strong>。真正意義上的無損畫質輸出的影片，渲染體積 1 分鐘視頻就超過 10G。我個人渲過最大的是 18 秒 44.5G 8k 視頻。</p>
<p>參考資料</p>
<p>[1]<a href="http://linux.chinaunix.net/techdoc/system/2006/07/03/935315.shtml">幾種壓縮算法原理介紹</a></p>
</div>
</div>




</div>


</div>
</div>