+++
date = "2017-02-18T13:00:00"
title = "熬夜寫完了論文，點「保存」的瞬間，斷電了"
titleimage = "http://pic1.zhimg.com/853938e4cfae4d8aea260184d9ad3e5c.jpg"
ga = 021813
+++

<div class="main-wrap content-wrap">
<div class="headline">

<div class="img-place-holder"></div>



</div>

<div class="content-inner">



<div class="question">
<h2 class="question-title">崩潰一致性：你的程序真的正確保存了數據嗎？</h2>
<div class="answer">



<div class="content">
<blockquote>這篇科普文章介紹了我們發表在 FSE2016 的研究工作&ldquo;Crash consistency validation made easy&rdquo;[1]。</blockquote>
<p><strong>我們解決什麼問題？</strong></p>
<p>先設想一個場景：你熬夜寫完了論文，終於覺得可以喘一口氣，然後舒舒服服地按下了 CTRL+S 保存文件。就在這時，你家的貓大爺拔掉了你的電源，你的文件還在嗎？</p>
<img class="content-image" src="https://pic1.zhimg.com/v2-d54e952667dfef376fb0e26e5089da60_b.jpg" alt="">
<p>（圖片來自網絡）</p>
<p>你肯定會想：這軟件那麼多用戶，那麼多專業的程序員，肯定沒事吧？最多就是我最後沒保存的幾個錯別字沒改過來唄。</p>
<p>這可不一定哦！這個問題更學術一點的定義叫&ldquo;崩潰一致性(crash consistency)&rdquo;。這個概念最早出現在文件系統的研究中&mdash;&mdash;文件系統是一個龐大的數據結構，而一個文件操作通常需要對數據結構的多個部分進行修改，因此在諸如斷電、系統故障等情況下保持文件系統的一致性就成爲了一個挑戰。崩潰一致性的基本概念在 Remzi 的經典教科書&ldquo;Operating Systems: Three Easy Pieces&rdquo;[2]中可以找到。</p>
<p>之前的研究工作表明，無論是 SSD 硬件[3]、數據庫系統[4]還是系統軟件[5]，在現有的文件系統實現(ext4, btrfs, NTFS, ...)上多少都有一些崩潰一致性的問題。連那麼厲害的專業程序員、久經考驗的開源和商業項目都沒搞定的事情，想必遍地的新手程序員們也會犯類似的錯誤吧(在讀完宗師大佬們的文章以後，我的內心就是這麼想的)？你猜對了。</p>
<p>事實是，你的文本編輯器真的有可能摧毀你的文件。不僅文本編輯器有這個問題，相當多的其他類型的應用軟件也存在這個問題。我們的論文就解決一個問題：</p>
<p>讓檢測應用程序崩潰一致性 bug 的過程儘量簡單，簡單到只要按一個鍵就可以了。</p>
<p><strong>從一個 Bug 例子說起</strong></p>
<p>我是一名苦逼的程序員，爲了養家餬口在外包公司做一個文本編輯器的項目。今天我完成的功能是存盤，在按下存盤鍵以後，將打開的文件保存。小 case，我在 Stackoverflow 上搜索了&ldquo;Java write file&rdquo;，然後搞到了如下(簡化的)代碼：</p>
<div class="highlight">
<pre><code class="language-js"><span class="k">void</span> <span class="nx">writeTextFile</span><span class="p">(</span><span class="nb">String</span> <span class="nx">path</span><span class="p">,</span> <span class="nb">String</span> <span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">PrintWriter</span> <span class="nx">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PrintWriter</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
    <span class="nx">writer</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
    <span class="nx">writer</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
<span class="p">}</span> 
</code></pre>
</div>
<p>作爲一名優秀的程序員，我想了想這樣好像不太對&hellip;&hellip;萬一在 write 的時候出了什麼狀況，用戶的文件不就丟了麼？所以最好先做個備份，肯定就萬無一失了。於是我把代碼改成了下面這樣，跑完測試就愉快地回家逗貓玩了。</p>
<div class="highlight">
<pre><code class="language-java"><span class="kt">void</span> <span class="nf">safelyWriteTextFile</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span><span class="o">,</span> <span class="n">String</span> <span class="n">content</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">backupPath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s">".tmp"</span><span class="o">;</span>
    <span class="n">writeTextFile</span><span class="o">(</span><span class="n">backupPath</span><span class="o">,</span> <span class="n">content</span><span class="o">);</span>
    <span class="n">deleteItem</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
    <span class="n">renameItem</span><span class="o">(</span><span class="n">backupPath</span><span class="o">,</span> <span class="n">path</span><span class="o">);</span>
<span class="o">}</span> 
</code></pre>
</div>
<p>然而事情沒那麼簡單。POSIX 說，你確實是按照 open -&gt; write -&gt; delete -&gt; rename 的順序執行了操作，但我纔沒有規定從文件系統的角度看，它們是按照你執行的順序完成的呢！什麼？這意味着&hellip;&hellip;</p>
<img class="content-image" src="https://pic4.zhimg.com/v2-25a98acbcd1ead9fe21300772345359b_b.png" alt="">
<p>如果系統偷偷調換 write 和 delete 操作的順序，並且在刪除操寫入磁盤後立即斷電，那不就等於把用戶的文件給刪掉了麼？也就是說，如果貓大爺真的在保存文件的時候拔掉了電源，這文件整個就沒(啊(論文就沒有了啊喂)！更可怕的是，現在的文件(統(比如默認設置下的 ext4)因爲只保留了元數據的日誌而沒有保存數據操作的日誌，這樣的&ldquo;亂序&rdquo;是真正能被觀察到的[5, 6]！</p>
<p>這段代碼來自文本編輯器 Ted，所幸的是這個 bug 成功地被我們的工具檢測到。</p>
<p><strong>崩潰一致性的自動檢測</strong></p>
<p>現在我們有足夠的動機去做一個工具檢測應用程序的崩潰一致性了。對於程序猿來說，最好的工具就是拿來就能用的工具。所以我們的工具 Crash Consistency Checke( (C3)只需要被測程序的可執行文件和一個測試用例，方法大致分爲 3(步(對技術細節沒有興趣的可以直接跳過)：</p>
<ol>
<li>運行一遍程序，取得我們認爲對於應用來說&ldquo;正確&rdquo;的文件系統快照。
<blockquote>什麼是&ldquo;正確&rdquo;的快照呢？我們認爲程序猿不會傻傻地把重要的用戶文件刪掉。所以，我們認爲所有元數據操作執行完畢後，內存中的文件系統快照代表了程序猿定義的&ldquo;正確&rdquo;狀態。實現上，我們用 ptrace 攔截程序發出的系統調用，並在系統調用結束後從內存中抓取快照。<img class="content-image" src="https://pic3.zhimg.com/v2-a11bf4d35c98d5a73fb275c3887da566_b.png" alt="">回到之前保存文件的例子，&ldquo;正確&rdquo;的快照中至少包含一個文件的內容。</blockquote>
</li>
<li>使用一個虛擬的磁盤捕獲所有的 I/O 請求，然後生成可能的崩潰現場。這個技術和已有的技術[4,5,6]十分類似。 <br>
<blockquote>實現上，我們寫了一個 ramdisk 的驅動，它從外面看錶現得和正常的磁盤一模一樣，但在後臺悄悄記錄了所有 I/O 操作的內容。根據這些 I/O 操作，就可以生成在 Linux 設備驅動規約允許條件下的各種崩潰現場。<img class="content-image" src="https://pic2.zhimg.com/v2-972ba8bc8fe9b75123e826afd2e87c59_b.png" alt=""><br><br>對於之前保存文件的例子，我們將會得到原文件被刪除、備份文件尚未寫入的一個文件系統快照。</blockquote>
</li>
<li>對每個崩潰現場計算與&ldquo;正確&rdquo;文件系統快照的編輯距離，如果距離很大，那這個崩潰現場就看起來很可疑。
<blockquote>兩個文件系統快照的編輯距離定義爲通過連續內容的刪除 / 移動 / 重命名操作將一個快照變爲另一個的最小次數。不過直接計算這個編輯距離是 NP-Complete 的，我們用了一些小技巧做了一個近似，求解一個它的(界(我纔不會告訴你最後就是給你兩個數組 A 和 B，判斷能不能把 A 裏刪掉一些元素重排以後變成 B，現在小學生都會做這個題啦！)。<img class="content-image" src="https://pic1.zhimg.com/v2-9cc5c2cfe74ca6bbca1637998d26d9c0_b.png" alt=""><br><br>顯然，對於一個沒有任何數據的文件系統快照，是無法通過編輯操作變成一個有數據的&ldquo;正確&rdquo;快照的，自然就被報告爲可疑的 bug 了。</blockquote>
</li>
</ol>
<p><strong>實驗結果</strong></p>
<p>我們從兩(類(命令行工具和生產力工具)挑選了總共 25 個應用，並對每個應用的一個簡單測試用例進行了測試，測試軟件在 ext4 默認設置下的崩潰一致性。結果是我們找到了 14 個崩潰一致性 bug，其中 11 個是開發者先前未知的 bug，讓我們看一看：</p>
<img class="content-image" src="https://pic3.zhimg.com/v2-906f69455938ff791bd23b0890ef26fe_b.png" alt="">
<p>列舉一些有代表性的 bug：</p>
<ol>
<li>對 in-place 的處理很容易出錯。比如 sort F -o F、用於兼容古老版本的功能就變成了有危險的操作，提供原地替換的 perl 也有類似的問題。</li>
<li>gzip 和 bzip2 犯了和之前例子類似的錯誤：在刪除舊文件之前沒有等待數據同步，從而導致了&ldquo;壓縮等於刪除&rdquo;的可能。各類生產力工具所犯的錯誤五花八門，保存文件的方式也各不相同，但很多都導致了同樣的後果&mdash;&mdash;數據丟失。</li>
<li>最後，gmake 的問題在於，在你運行的(本(如 gcc)崩潰後，目標文件的時間戳被更新，內容卻損壞了，這樣如果這個文件最後被直接打包，就可能會導致嚴重的後果。雖然說這可以算是 gcc 的問題(但(1) gcc 並不必須要提供崩潰一致性，(且(2) 這個問題最終影響 gmake 的用戶，我們覺得讓 gmake 的用戶知道這件事可能發生是很重要的。</li>
</ol>
<p>在驚訝於這麼多程序都有這類 bug 的同時，我們也對剩下通過測試的應用提出表揚，比如著名的 Vim 和 Emacs。</p>
<p><strong>最後的提醒</strong></p>
<ul>
<li>小心處理你的文件。看了這麼多血淋淋的例子，我想你以後在保存數據的時候也會格外小心了吧。</li>
<li>庫函數的支持非常重要。在和開源社區交互的過程中，我們很高興地看到很多庫都開始提供安全的文件(作(例如 Qt 中的 QSaveFile 和 GTK 中的 g_file_replace)。與此同時，更多的新興平臺則做得不夠好。比如 Atom 的開發者意識到了這類 bu( (而且真的有人在使用中觸發了這個 bug)，但 Node.js 的系統庫卻缺乏可移植的方案讓他們能更好地避免這種問題。</li>
<li>留意崩潰一致性問題。gmake 的例子警示我們，崩潰一致性問題不僅是那些保存數據的人需要關心的，也許哪天就悄悄地影響了你。<strong>所以如果你覺得這篇文章很有趣，請轉發它讓更多的人能意識到這個問題的存在</strong><strong>。</strong></li>
</ul>
<p><strong>參考文獻</strong></p>
<p>[1] Y Jiang, H Chen, F Qin, C Xu, X Ma, J Lu. Crash consistency validation made easy. In <em>Proceedings of the Symposium on the Foundations of Software Engineerin(</em> (FSE), 133--143, 2016.</p>
<p>[2] R H Arpaci-Dusseau, A C Arpaci-Dusseau. <em>Operating Systems: Three Easy Piece(</em> (v0.91), Arpaci-Dusseau Books, 2015.</p>
<p>[3] M Zheng, J Tucek, F Qin, M Lillibridge. Understanding the robustness of SSDS under power fault. In <em>Proceedings of the USENIX Conference on File and Storage Technologie(</em> (FAST), 271--284, 2013.</p>
<p>[4] M Zheng, J Tucek, D Huang, F Qin, M Lillibridge, E S Yang, B W Zhao, S Singh. Torturing databases for fun and profit. In <em>Proceedings of the Conference on Operating Systems Design and Implementatio(</em> (OSDI), 449--464, 2014.</p>
<p>[5] T S Pillai, V Chidambaram, R Alagappan, S Al-Kiswany, A C Arpaci-Dusseau, R H Arpaci-Dusseau. All file systems are not created equal: On the complexity of crafting crash-consistent applications. In <em>Proceedings of the Conference on Operating Systems Design and Implementatio(</em> (OSDI), 433--448, 2014.</p>
<p>[6] J Yang, C Sar, D Engler. EXPLODE: A lightweight, general system for finding serious storage system errors. In <em>Proceedings of the Conference on Operating Systems Design and Implementatio(</em> (OSDI), 131--146, 2006.</p>
<p><strong>論文信息</strong>：&ldquo;Crash consistency validation made easy&rdquo;的<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//moon.nju.edu.cn/spar/publication/jiang_crash_2016.pdf" target="_blank" rel="nofollow noreferrer">論文</a>、<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//moon.nju.edu.cn/spar/publication/c3_talk.pdf" target="_blank" rel="nofollow noreferrer">會議報告</a>和<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//jiangyy.github.io/c3/" target="_blank" rel="nofollow noreferrer">相關代碼</a>。</p>
<p><strong>作者簡介</strong>：本文作者包括南京大學博士生<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//moon.nju.edu.cn/%7Ejyy" target="_blank" rel="nofollow noreferrer">蔣炎巖</a>、俄亥俄州立大學的博士生陳海騁和<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//web.cse.ohio-state.edu/%7Eqin/" target="_blank" rel="nofollow noreferrer">秦鋒</a>教授、南京大學的<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//cs.nju.edu.cn/changxu/" target="_blank" rel="nofollow noreferrer">許暢</a>、<a class=" wrap external" href="https://link.zhihu.com/?target=http%3A//cs.nju.edu.cn/xxm" target="_blank" rel="nofollow noreferrer">馬曉星</a>和呂建教授。</p>



</div>
</div>
</div>


</div>
</div>