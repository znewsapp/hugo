+++
date = "2017-01-02T09:00:00"
title = "如何跟老代碼友好相處？"
titleimage = "http://pic4.zhimg.com/2126c7d025097325a7ad25aff87f7267.jpg"
ga = 010209
+++

<div class="main-wrap content-wrap">
<div class="headline">

<div class="img-place-holder"></div>



</div>

<div class="content-inner">



<div class="question">
<h2 class="question-title"></h2>
<div class="answer">



<div class="content">
<p>在 Office 工作也已經超過兩年了。儘管 Office 是微軟 C++ 新標準最有力的推手之一，我在這裏面學到的東西其實跟語言倒沒什麼關係，主要還是跟老代碼(legacy code)相關的事情。<a class="member_mention" href="https://www.zhihu.com/people/42c7d84ae7d50b31d1861f19f3842a14">@Hush</a> 曾經安利過我一本《Working Efficiency with Legacy Code》，不過我還沒看，你們有興趣可以去讀一讀。</p>
<p>面對 legacy code 的情況有很多，不僅僅在工作中會遇到一些 198x 年寫的代碼跟 2016 年寫的代碼混在一起的情況，哪怕是開發自己的 GacUI 也會有。儘管 GacUI 公開立項是在 C++11 發佈之前不久，但是實際上整份代碼是在我讀大學的時候造各種輪子的時候，慢慢組合起來的。現在在註釋裏面還能看到類似 Vczh Library ++ 3.0 的字樣，那 1.0 是什麼呢？</p>
<p>Borland 是在我上大一的時候把 Delphi 賣掉的，我也是差不多在那個時候第一次感覺到了自己學到的東西好像突然就沒有價值了，於是趁這個機會全方面轉向 C++。第一個任務自然就是要把我以前寫 Delphi 的時候積累下來的輪子用 C++ 重寫一遍，那就是 Vczh Library++ 1.0。++ 的意思就是這是 C++ 寫的，懷念 Delphi。後來慢慢的一邊修改一遍重構一邊刪除各種東西，因此我自己所有的 C++ 個人項目都是圍繞着這個庫來開發的。從這個角度來看，GacUI 的一部分代碼算起來也有十年之久了，這個年齡其實已經超過了大家工作的時候能遇到的大部分項目的年齡了。所以在這裏介紹的經驗，對大部分的人都應該是合適的。</p>
<p><strong>Legacy code 造成的最大的問題是什麼？其實就是最新的 best practice 和標準，與過去的開發經驗的矛盾</strong>。這是面對 legacy code 開發的時候，遇到的的主要矛盾。這個問題在 Office 尤爲明顯。GacUI 嘛，也只有十幾萬行。只要我哪天中了彩票，我可以辭職在家裏從頭優化，花個一年還是能夠把所有的東西都改成最好的。至於 Office，哪怕你讓全球的辦公軟件開發商停下來等你，好讓你把所有的代碼都翻新一遍改成最好的，也是一件不可能的事情。</p>
<p>Office 客戶端的一個版本的代碼（不包括分支也不包括歷史），拉下來所有的文件就有 300 多 G。這裏面有差不多 20-30G 其實是所有平臺的編譯器和 SDK，還有一些全球語言的字符串和配置，還有一些圖標和測試，剩下的佔了大部分內容的都是代碼。Office 現在有很多千人在做，30 多年通過不斷的收購以及打字，最終創造了這麼多代碼。平均每個人要負責的代碼就有超過 30M 那麼多（是 GacUI 的十幾倍）。要全部翻新一遍，量子計算機應該也普及了。<strong>所以首先我們要明白的事情就是，用最新的標準來要求程序員產出的代碼是不可能的。哪怕是新的代碼，只要這些東西跟古老的部分有一點關係，你做起來就會更加困難</strong>。那落實到具體應該怎麼做呢？實際上最合適的辦法就是，當你在修改哪一個年代的代碼的時候，就按照那個時候的要求，也就是整份代碼的風格來寫。</p>
<p>其次就是重構。前輩們的經驗告訴我們，<strong>重構最大的好處就是，通過現在多花一點時間，來節省未來無窮多的時間。那節省的時間到底是什麼呢？其實就是新的需求跟就的架構的矛盾帶來的開發效率的降低</strong>。你爲了現在的需求做了一個設計，很好的滿足了需要，架構弄好了之後業務邏輯寫出來特別的快。但是需求總是會變更的，總有一天你的架構就會成爲落後的架構，在上面實現新的需求就會變得很困難，開發效率就降低了。在我們總是希望軟件的生命無限延續的前提下，我們需要適當地做一些重構，來滿足現在或者短期的快速開發業務邏輯的需要。</p>
<p>舉個很簡單的例子，如果我們在命令行裏面打印一個菜單，按下數字鍵就可以做一些不同的事情，那當軟件剛剛誕生，裏面的東西還不多的時候，我們會直接的使用 if(input == 1) { ... } else ... 的方法來寫。後來你加進去的東西越來越多，你會發現 if 的那些代碼就總是重複，所以有一天你改成了 switch(input) { case 1: ... break; ...}。再後來，你發現由於業務邏輯的變化，這個菜單開始有增刪改的要求，那你總不能每次拿掉一個東西就把所有的 case 重新修正一遍吧？這個時候就會開始使用函數指針數組，在 main 函數裏面初始化之後，input 就可以直接當下標。後來這個軟件中遇到了更加複雜的需求，菜單開始不是線性的了，你可能也就即將開始感覺到一個 UI 庫的重要性，慢慢的就引進了各種設計模式。軟件的迭代從宏觀上來看，道理也是一樣的。</p>
<p>但是面對 legacy code 的重構有其獨特的難點。一個持續進化軟件的 legacy code 很 legacy，通常也就意味着這個軟件也不小，那你重構的時候需要處理的地方就非常多。你這項工作可能要持續半年，在這半年裏面你又不能 push，因爲重構了一半的代碼多半是跑不起來的。別人也不可能停下來等你重構，所以會在舊的架構的基礎上不斷地添加新東西，那麼你需要處理的事情就會越來越多，直到爆炸。這也是很多古老的軟件無法進行任何重構的重要原因之一。</p>
<p>但是這個問題並不是無法解決的。在 Office 裏面有三種風格的重構。</p>
<p>第一種就是靠一個牛逼的人，就是可以迅速結束戰鬥，同時一個 change 上去感染了幾千個 C++ 代碼文件，上去還能跑。遇到這樣的人只能每天路過辦公室門口的時候進行膜拜。我就有幸目睹了一個 principal 的毛子幹了這樣的事情，因爲之前一直都有合作，覺得真是太偉大了。</p>
<p>第二種就是讓大家一起來。你開一個 branch，把基礎的東西弄好，然後讓每一個人都在自己的工作之餘加入到你的重構工作來，其實也就是把他們自己的組件的代碼改成兼容你的新架構的。等到所有的組件都翻新過後，最後讓大家一起再解決一遍 pull request 裏面的 conflict。</p>
<p>第三種就是，在舊的庫的旁邊寫一個新的庫，然後只要你庫的對象不是在整個系統裏到處傳播的，那麼你總是可以一個一個文件慢慢地把#include 換掉，把代碼改成兼容新庫的形式。這樣在後面修改這個文件的人自然也就被迫使用你的新庫了。一直到所有對老庫的#include 都消失了，把老的刪掉，重構工作就完成了。這樣做的好處是你的新代碼是不斷地 push 給大家的，不會有 merge 的噩夢出現。</p>
<p><strong>但是重構也不是萬能的。因爲畢竟一個架構如果沒有影響到你的開發效率的話，爲什麼要去重構他呢？做這個很容易就變成過度設計了</strong>。這在 GacUI 的身上就很明顯。大家可能會發現，我在知乎上說 C++ 新標準下面應該如何如何做的時候，GacUI 出現的卻總是那些過時的方法。其實一個很重要的原因就是，事情還沒發展到我非翻新舊代碼不可的時候。</p>
<p>舉個例子，C++11 說你們可以用 shared_ptr、weak_ptr 和 unique_ptr 來表達不同對象的生命週期，從而最大程度的避免對裸指針的使用（避免粗心用錯）。但是 GacUI 仍然大量使用 Ptr&lt;T&gt;和裸指針。其實原因有三個。</p>
<p>第一個就是，代碼是舊的，在這套東西還沒反映在標準裏面的時候，Ptr&lt;T&gt;已經被廣泛使用了。那現在我要不要再添加新功能的時候，使用 shared_ptr，讓系統裏面同時出現兩套智能指針呢？這當然是不行的，因爲智能指針有自己管理引用計數的方法，不同的智能指針幾乎是不可能混用的。</p>
<p>第二個就是，既然如此，爲什麼我不把 Ptr&lt;T&gt;刪掉直接全部換成 shared_ptr？這就反映了上面粗體的內容。Ptr&lt;T&gt;換成 shared_ptr 真的就能提高開發效率嘛？如果 GacUI 是由很多個人寫的，那這個很難說，畢竟不是所有人都知道 Ptr&lt;T&gt;的各方面細節。但是我作爲 GacUI 的&ldquo;幾乎&rdquo;唯一的作者，我對代碼的所有方面都有無限的瞭解，我用裸指針也很少犯錯誤，所以 shared_ptr 的好處仍然不值得我做一次全文替換。</p>
<p>第三個就是，其實 Ptr&lt;T&gt;還有 shared_ptr 所沒有的功能。GacUI 的腳本引擎支持腳本創建新的類，這個新類可以繼承自若干個 C++ 裏面的類，新類還能被反射出來使用。這就在實際上造成了，在內存佈局上面，新類其實就是 N 個對象組成的，N-1 個 C++ 裏面的類，還有一個腳本創建的模擬的類。那麼這幾個類的實例其實應該共享同一個引用計數的指針。不然父類實例用了一半，子類實例被早早析構了，這就尷尬了。</p>
<p>大家可以發現，用新的智能指針實現這個東西的方法就是，腳本創建的類去 unique_ptr 所有的父類，然後 dynamic_cast 其實就是去獲得一個內部用 shared_ptr 裝着子類的、父類接口的 shared_ptr 或 unique_ptr，實現就是把虛函數 redirect 到父類那裏去。當然這樣你的父類就要求全部都寫成接口（COM 就是這麼幹的）。看起來很彆扭是不是？因爲 C++ 這一套東西對這個場景其實不能很好的表達。</p>
<p>但是反過來，我可以很輕易地通過修改 Ptr&lt;T&gt;、可以被腳本繼承的類的基類 DescriptableObject，加上通過 SFINAE 來讓 Ptr&lt;T&gt;面對普通類型的時候使用普通的實現，來輕鬆的做到這一點。要換成 shared_ptr 就要變成另一套做法了，重構難度還是挺大，超過了對以後開發效率的改善。COM 的 Aggregation 是對相同的問題的另一套做法，我不小心重新發明了一次。</p>
<p>類似的內容還有很多，C++11 出了 for(auto x : xs){ ... }，然而我所有的地方還是用 FOREACH(X, x, xs){ ... }宏。C++17 即將就要有 range 了，而我卻有老早就爲了彌補 range 不存在，#include &lt;algorithm&gt;裏面的東西組合起來又太難而山寨的 Linq。C++11 有了 T&amp;&amp;之後，容器就變得非常好用。但是我自己需要的容器不多，加上這個 T&amp;&amp;的支持也不難，所以我最終也沒有把自己的類換成 STL。給定新標準下一個支持 X&amp;&amp;夠早的 X 類，一個返回 X 類型的屬性的 setter 最好的寫法是 SetX(X x)，不是 X&amp;&amp;x，也不是 const X&amp; x，也不是兩個都有。但是其實很多地方我也沒換。因爲這些東西的替換實際上都無法帶來什麼顯著的好處，所以乾脆就留着了。</p>
<p>剩下的還有很多瑣碎的地方我也就不一一提到了，10 年前的一些次要組件現在看起來可能會發現代碼裏有各種問題，但是反正已經寫好了，改得更好用起來也不會更方便，乾脆就放着不管了。</p>
<p><strong>GacUI 就幾乎只有我一個人在寫，添加新 feature 趕緊做完，好騰出手來造新的輪子，纔是第一目標。代碼是否符合最新的 C++ 規範，那是其次</strong>。這放在很多商業軟件上也是成立的。我的理由是由於我想造新輪子所以要趕緊把 GacUI 做完，商業軟件爲了生存下去給自己員工漲工資要迅速發佈和迭代產品，這兩個理由其實是等價的。</p>
<p>回到 Office 裏面，其實也會經常遇到類似的問題。三個不同的古老的組件，使用了收購回來的時候內部就已經有的三個字符串類。有一天我要把他們整合到一起，怎麼辦？其實最經濟的方法就是，把他們都嚴嚴實實地封裝進自己的接口裏面，別人不要去碰他們，只有我來碰。那我內部最多也就是多寫幾個噁心的字符串轉換的代碼而已。<strong>隔絕的好處就是，落後的組件的實現，通過我改頭換面之後，對別人的傷害降到了最低</strong>。因此我也沒有必要去重構他們了。這樣就使用最短的時間，在保證質量的前提下，寫出了不會降低別人開發效率的代碼。</p>
<p><strong>重構是要看成本的。當然反過來，哪怕是一個重構很難，規模很大，但是他創造的效益更大的話，就值得你去說服大老闆讓你去做。</strong></p>
<p>在講完了重構之後，剩下的一個大問題就是，那添加新的代碼怎麼辦？其實這也是要按照相同的標準去做的。你添加新的代碼，是否會因爲舊的架構的影響，讓使用你的新代碼進行二次開發的人的開發效率被降低？如果你認爲答案是&ldquo;會&rdquo;，這可能就是一個重構的信號，你要先重構，然後再加新代碼。否則，你就按照跟原有的部分兼容的方法去寫就好了。當然了，如果情況允許的話，你也可以通過上面講到的第三種重構的方法，先從你的新代碼開始，推廣新的架構。等整個系統的每一個角落都被你翻新了之後，舊的架構就刪掉了，你就在完成了一次重構的同時，要加的新 feature 早就上線了，不會影響到 release 的日期。</p>
<p>總的來說，爲什麼會有這些準則？其實根本的原因是，修改代碼會造成 regression，如果你測試的覆蓋不夠，重構也會引發大量的問題（這就是爲什麼重構跟測試是相輔相成的，少了一個都不行）。老的代碼沒有重構的必要就不要重構，你的整體工作量也就大大降低了，同時保證了軟件可以被 release。</p>
<p>一個剛剛加入工作的程序員，或者是一個學生，可能在遇到類似的問題的時候都比較激進，然後就會被事實教做人。其實這都是因爲年輕人眼界不夠高，沒辦法在全局觀上看到很多事情背後的 cost。<strong>所以如果你恰好加入了一個古老的軟件的項目組，不要對舊的東西產生抵觸，就是一個良好的開始</strong>。</p>



</div>
</div>
</div>


</div>
</div>